---
title: "PCA and Heatmap"
subtitle: "Workshop on ggplot"
author: "`r paste0('<b>Lokesh Mano</b> â€¢ ',format(Sys.time(), '%d-%b-%Y'))`"
output:
  bookdown::html_document2:
          toc: true
          toc_float: true
          toc_depth: 4
          number_sections: true
          theme: flatly
          highlight: tango
          df_print: default
          code_folding: "none"
          self_contained: false
          keep_md: false
          encoding: 'UTF-8'
          css: "assets/lab.css"
---
```{r, include=FALSE}
hooks = knitr::knit_hooks$get()
hook_foldable = function(type) {
  force(type)
  function(x, options) {
    res = hooks[[type]](x, options)
    
    if (isFALSE(options[[paste0("fold.", type)]])) return(res)
    
    paste0(
      "<details><summary>", type, "</summary>\n\n",
      res,
      "\n\n</details>"
    )
  }
}
knitr::knit_hooks$set(
  output = hook_foldable("output"),
  plot = hook_foldable("plot")
)
```

```{r,child="assets/header-lab.Rmd"}
```

```{r, echo=FALSE, warning=FALSE, message=FALSE}
library(dplyr)
library(ggplot2)
library(reshape2)
data("iris")
md <- read.table("data/metadata_raw.csv", header = T, sep = ";")
rownames(md) <- md$Sample_ID

library(tidyverse)
```

# PCA

Let us first make a PCA object. For this, we will use the `VST` data, because it makes sense to use the normalised data for building the PCA. To run PCA, we use the R function `prcomp()`. It takes in a matrix where samples are rows and variables are columns. Therefore, we transpose our count matrix using the function `t()`. If we do not transpose, then PCA is run on the genes rather than the samples. 

```{r, warning=FALSE, message=FALSE}
gc_vst <- read.table("data/counts_vst.txt", header = T, row.names = 1, sep = "\t")
vst_pca <- prcomp(t(gc_vst))
```

## Variance of components

The next line of code plots the variance explained by the top PCs.

```{r, warning=FALSE, message=FALSE}
comp_var <- function(x) x^2/sum(x^2)
library(scales)

vst_pca$sdev %>% 
  as_tibble() %>% 
  comp_var() %>% 
  mutate(Comp = colnames(vst_pca$x)) %>% 
  slice(1:9) %>% 
  ggplot(aes(x=Comp, y = value)) + 
  geom_bar(stat = "identity") +
  xlab("Principal Components") +
  scale_y_continuous(name = "Variance Explained", breaks = seq(0,0.8,0.1),labels = percent) +
  theme_classic(base_size = 14)

```

## Scatter plot

So, looks like the first two components explain almost 85% of the data. Now, let us look into building the plot out of these componenets. From the above object, to get the scatter plot for the samples, we need to look inot `vst_pca$x`. Then, we combine this data (as shown below) with the metadata to use different aesthetics and colors on the plot.

```{r, warning=FALSE, message=FALSE}
vst_pca$x
```

And, if you check the `class()` of this object, you will realize that this is a `matrix`. To be able to comfortably use `tidyverse` on this object, we must first convert this to a `data.frame`. 

```{r, warning=FALSE, message=FALSE}
vst_pca_all <- vst_pca$x %>%
  as.data.frame() %>%
  rownames_to_column(var = "Sample_ID") %>%
  full_join(md, by = "Sample_ID")

# Just to keep the order the right way.
vst_pca_all$Sample_Name <- factor(vst_pca_all$Sample_Name, levels = c("t0_A","t0_B","t0_C","t2_A","t2_B","t2_C","t6_A","t6_B","t6_C","t24_A","t24_B","t24_C"))
vst_pca_all$Time <- factor(vst_pca_all$Time, levels = c("t0","t2","t6","t24"))
vst_pca_all$Replicate <- factor(vst_pca_all$Replicate, levels = c("A","B","C"))

ggplot(vst_pca_all, aes(x=PC1, y=PC2, color = Time)) +
  geom_point(size = 3, aes(shape = Replicate)) +
  geom_vline(xintercept = 0, linetype=2) +
  geom_hline(yintercept = 0, linetype=2) +
  theme_bw() +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) 
```



# Session info

```{r, fold.output=FALSE, fold.plot=FALSE}
sessionInfo()
```

__End of document__